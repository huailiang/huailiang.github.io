<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Valkan 基础渲染流程</title>
  <meta name="description"
    content="Vulkan 中的重要组件以及它们的工作流程如下图所示，接下来的文章中会针对每个组件进行学习讲解并配上相关的示例代码，首先是Instance、Device和Queue组件。">

  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://huailiang.github.io/blog/2019/vulkan/">
  <link rel="alternate" type="application/rss+xml" title="Huailiang Blog"
    href="https://huailiang.github.io/feed.xml" />

</head>

<body>
  <main>
    <header class="site-header">
  <div class="container">
    <h1><a href="/">Hom<span>e</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
        <li><a href="/about" title="About">About</a>
        </li>
        
        <li><a href="/blog" title="Blog">Blog</a>
        </li>
        
        <!-- <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i></a></li> -->
        <li><a href="/category/" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>
    <script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });

</script>
    <div class="container">
      <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">Valkan 基础渲染流程</h1>
      <p class="post-meta">Sep 8, 2019 •
        Huailiang</p>
    </header>

    <div class="post-content">
      <p>Vulkan 中的重要组件以及它们的工作流程如下图所示，接下来的文章中会针对每个组件进行学习讲解并配上相关的示例代码，首先是Instance、Device和Queue组件。</p>

<p><img src="/img/post-unity/cmd4.jpeg" alt="" /></p>

<h3 id="instance-组件">Instance 组件</h3>

<p>在开始创建Device等组件之前，需要创建一个VkInstance对象。</p>

<p>通过vkCreateInstance方法创建VKInstance对象，以下是函数原型，在 <vulkan.h> 头文件中。</vulkan.h></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 声明的函数指针的形式
</span><span class="k">typedef</span> <span class="n">VkResult</span> <span class="p">(</span><span class="n">VKAPI_PTR</span> <span class="o">*</span><span class="n">PFN_vkCreateInstance</span><span class="p">)</span>
<span class="p">(</span><span class="k">const</span> <span class="n">VkInstanceCreateInfo</span><span class="o">*</span> <span class="n">pCreateInfo</span><span class="p">,</span> <span class="c1">// 提供创建的信息
</span><span class="k">const</span> <span class="n">VkAllocationCallbacks</span><span class="o">*</span> <span class="n">pAllocator</span><span class="p">,</span> <span class="c1">// 创建时的回调函数
</span><span class="n">VkInstance</span><span class="o">*</span> <span class="n">pInstance</span><span class="p">);</span>                <span class="c1">// 创建的实例
</span></code></pre>
</div>

<p>Queue组件是用来和物理设备沟通的桥梁，而具体的沟通过程就需要Command-Buffer（命令缓冲区）组件，它是若干命令的集合，我们向Queue提交Command-Buffer，然后才交由物理设备GPU进行处理。</p>

<p>在vkCreateInstance函数中看到有个名为VkInstanceCreateInfo类型的参数，这就是包含了VKInstance要创建的信息。</p>

<p>它的参数信息有点多：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkInstanceCreateInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>             <span class="n">sType</span><span class="p">;</span>  <span class="c1">// 一般为方法对应的类型
</span>    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>                 <span class="n">pNext</span><span class="p">;</span> <span class="c1">// 一般为 null 就好了
</span>    <span class="n">VkInstanceCreateFlags</span>       <span class="n">flags</span><span class="p">;</span>  <span class="c1">// 留着以后用的，设为 0 就好了
</span>    <span class="k">const</span> <span class="n">VkApplicationInfo</span><span class="o">*</span>    <span class="n">pApplicationInfo</span><span class="p">;</span> <span class="c1">// 对应新的一个结构体 VkApplicationInfo
</span>    <span class="kt">uint32_t</span>                    <span class="n">enabledLayerCount</span><span class="p">;</span> <span class="c1">// layer 和 extension 用于调试和拓展
</span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span>          <span class="n">ppEnabledLayerNames</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                    <span class="n">enabledExtensionCount</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span>          <span class="n">ppEnabledExtensionNames</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkInstanceCreateInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>除了还需要创建一个VkApplicationInfo对象，还可以设置Layer和Extension。其中：Layer是用来错误校验、调试输出的。为了提供性能，其中的方法之一就是减少驱动进行状态、错误校验，而 Vulkan 就把这一层单独抽出来了。</p>

<center><img src="/img/post-unity/cmd3.jpg" /></center>
<p><br /></p>

<p>Layer 在整个架构中的位置如上图，Vulkan API直接和驱动对话，而Layer处于应用和Vulkan API之间，供开发者进行调试。另外，Extension就是Vulkan支持的拓展，最典型的就是Vulkan的跨平台渲染显示，就是通过拓展来完成的，比如在Android、Windows上使用Vulkan都需要使用不同的拓展才可以把内容显示到屏幕上。</p>

<p>VkApplicationInfo 结构体，也是创建 Instance 的必要参数之一</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkApplicationInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>    <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>        <span class="n">pNext</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>        <span class="n">pApplicationName</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">applicationVersion</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>        <span class="n">pEngineName</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">engineVersion</span><span class="p">;</span>
    <span class="kt">uint32_t</span>           <span class="n">apiVersion</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkApplicationInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>参数释义就比较容易理解了，设置应用的名称、版本号等，有了它们就可以创建Instance对象了。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkApplicationInfo</span> <span class="n">app_info</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">app_info</span><span class="p">.</span><span class="n">apiVersion</span> <span class="o">=</span> <span class="n">VK_API_VERSION_1_0</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">applicationVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">engineVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_APPLICATION_INFO</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pEngineName</span> <span class="o">=</span> <span class="n">APPLICATION_NAME</span><span class="p">;</span>
<span class="n">app_info</span><span class="p">.</span><span class="n">pApplicationName</span> <span class="o">=</span> <span class="n">APPLICATION_NAME</span><span class="p">;</span>

<span class="n">VkInstanceCreateInfo</span> <span class="n">instance_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// type 就是结构体的类型
</span><span class="n">instance_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">pApplicationInfo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">app_info</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// Extension and Layer 暂时不用,可空
</span><span class="n">instance_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">instance_info</span><span class="p">.</span><span class="n">enabledLayerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">VkResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">vkCreateInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance_info</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">instance</span><span class="p">);</span>
</code></pre>
</div>

<p>当每调用一个创建函数后，返回的类型都是VkResult，只要VkResult大于0，那么执行就是成功的。另外还有个参数是VkAllocationCallbacks，表示函数调用时的回调，需要传递一个函数指针，在后面的各种调用中都会看到它的身影，如果有用到可以传参，一般为nullptr就好了。关于每个结构体，它每个参数的具体释义，参考<a href="https://www.khronos.org/registry/vulkan/specs/1.0/pdf/vkspec.pdf">vkspec.pdf</a>，里面有对每个参数、结构体的详细释义。</p>

<h2 id="device-组件">Device 组件</h2>

<p>有了Instance组件，就可以创建Device组件了，创建一个VkDeviceCreateInfo的结构体表示Device的创建信息。而Device具体指的是逻辑上的设备，可以说是对物理设备的一个逻辑上的封装，而物理设备就是VkPhysicalDevice对象。在某些情况下，可能会具有多个物理设备，如下图所示，因此要先枚举一下所有的物理设备：</p>

<center><img src="/img/post-unity/cmd2.jpg" /></center>
<p><br /></p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">gpu_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// 第一次调用只为了获得个数
</span><span class="n">VkResult</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_size</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
</code></pre>
</div>

<p>在 vkEnumeratePhysicalDevices方法中，传入的第二个参数为gpu的个数，第三个参数为null，这样的一次调用会返回gpu的个数到gpu_size变量。</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span> <span class="n">gpus</span><span class="p">;</span>
<span class="n">gpus</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">gpu_size</span><span class="p">);</span>
<span class="c1">// vector.data() 方法转换成指针类型
// 第二次调用获得所有的数据
</span><span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_size</span><span class="p">,</span> <span class="n">gpus</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</code></pre>
</div>

<p>当再一次调用vkEnumeratePhysicalDevices函数时，第三个参数不为null，而是相应的VkPhysicalDevice容器，那么gpus会填充 gpu_size个的VkPhysicalDevice对象。这也算是Vulkan API调用的一个固定套路了，调用两次来获得数据，在后面的代码中也会经常看到这种方式。有了VkPhysicalDevice对象之后，可以查询VkPhysicalDevice上的一些属性，以下函数都可以查询相关信息：</p>

<ul>
  <li>vkGetPhysicalDeviceQueueFamilyProperties</li>
  <li>vkGetPhysicalDeviceMemoryProperties</li>
  <li>vkGetPhysicalDeviceProperties</li>
  <li>vkGetPhysicalDeviceImageFormatProperties</li>
  <li>vkGetPhysicalDeviceFormatProperties</li>
</ul>

<p>在这里需要用到的属性是QueueFamilyProperties，获得该属性的方法调用方式和获得VkPhysicalDevice数据方式一样，也是一个两次调用。如果有设备有多个GPU，那么这里取第一个来获取它的相关属性：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 第一次调用，获得个数
</span><span class="kt">uint32_t</span> <span class="n">queue_family_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 第二次调用，获得实际数据
</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span> <span class="n">queue_family_props</span><span class="p">;</span>
<span class="n">queue_family_props</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
<span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="n">queue_family_props</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>

<p>QueueFamilyProperties 的结构体含义如下：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkQueueFamilyProperties</span> <span class="p">{</span>
    <span class="n">VkQueueFlags</span>    <span class="n">queueFlags</span><span class="p">;</span>      <span class="c1">// 标识位：表示 Queue 的功能
</span>    <span class="kt">uint32_t</span>        <span class="n">queueCount</span><span class="p">;</span>         
    <span class="kt">uint32_t</span>        <span class="n">timestampValidBits</span><span class="p">;</span>
    <span class="n">VkExtent3D</span>      <span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</code></pre>
</div>

<p>其中：queueFlags表示该Queue的能力，有的Queue是用来渲染图像的，这个和我们的使用最为密切，还有的Queue是用来计算的。</p>

<p>具体的 Flag 标识如下：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkQueueFlagBits</span> <span class="p">{</span>
    <span class="n">VK_QUEUE_GRAPHICS_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>         <span class="c1">// 图像相关
</span>    <span class="n">VK_QUEUE_COMPUTE_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>          <span class="c1">// 计算相关
</span>    <span class="n">VK_QUEUE_TRANSFER_BIT</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
    <span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span> <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
    <span class="n">VK_QUEUE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkQueueFlagBits</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">VkFlags</span> <span class="n">VkQueueFlags</span><span class="p">;</span>
</code></pre>
</div>

<p>一般来说，我们用的是queueFlags为VK_QUEUE_GRAPHICS_BIT标识位的Queue。那么Queue究竟是什么？物理设备可能会有多个 Queue，不同的 Queue 对应不同的特性。在文章最开始的图中可以看到，Command-buffer是提交到了Queue，Queue再提交给Device去执行。Queue可以看成是应用程序和物理设备沟通的桥梁，我们在Queue上提交命令，然后再交由GPU去执行。</p>

<h2 id="device-组件-1">Device 组件</h2>

<p>创建一个Device对象，不仅需要指定具体的物理设备VkPhysicalDevice，另外还需要该物理设备上的Queue相关信息。在VkDeviceCreateInfo结构体中需要一个参数是VkDeviceQueueCreateInfo，它的创建如下：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Queue 所需的相关信息
</span><span class="n">VkDeviceQueueCreateInfo</span> <span class="n">queue_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 找到属性为 VK_QUEUE_GRAPHICS_BIT 的索引
</span><span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> 
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue_family_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_family_props</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueFlags</span> <span class="o">&amp;</span> <span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">float</span> <span class="n">queue_priorities</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
<span class="c1">// 结构体的类型
</span><span class="n">queue_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">queueCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">// Queue 的优先级
</span><span class="n">queue_info</span><span class="p">.</span><span class="n">pQueuePriorities</span> <span class="o">=</span> <span class="n">queue_priorities</span><span class="p">;</span>
</code></pre>
</div>

<p>接下来就可以完成Queue的创建：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Device 所需的相关信息类
</span><span class="n">VkDeviceCreateInfo</span> <span class="n">device_info</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">device_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="c1">// Device 所需的 Queue 相关信息
</span><span class="n">device_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// Queue 个数
</span><span class="n">device_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue_info</span><span class="p">;</span>    <span class="c1">// Queue 相关信息
// Layer 和 Extension 暂时为空，不影响运行，后续再补上
</span><span class="n">device_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">enabledLayerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">device_info</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="queue-组件">Queue 组件</h2>

<p>完成了Device创建之后，Queue的创建也简单多了，直接调用如下函数就好了：</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">VKAPI_PTR</span> <span class="o">*</span><span class="n">PFN_vkGetDeviceQueue</span><span class="p">)</span>
<span class="p">(</span><span class="n">VkDevice</span> <span class="n">device</span><span class="p">,</span>   <span class="c1">// 创建的 Device 对象
</span><span class="kt">uint32_t</span> <span class="n">queueFamilyIndex</span><span class="p">,</span> <span class="c1">// queueFlags 为 VK_QUEUE_GRAPHICS_BIT 的索引
</span><span class="kt">uint32_t</span> <span class="n">queueIndex</span><span class="p">,</span>        
<span class="n">VkQueue</span><span class="o">*</span> <span class="n">pQueue</span><span class="p">);</span>       <span class="c1">// 要创建的 Queue
</span><span class="n">vkGetDeviceQueue</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
</code></pre>
</div>

<p>完成了Instance、Device、Queue组件的创建之后，还有一件要做的事情就是释放它们，销毁组件。<br />
按照先进后出的方式进行销毁，Instance最先创建反而最后销毁，和Device相关联的Queue当Device销毁了，Queue也随之销毁了。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 销毁 Device
</span><span class="n">vkDestroyDevice</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="c1">// 销毁 Instance
</span><span class="n">vkDestroyInstance</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">instance</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="vulkan-commandbuffer">Vulkan Commandbuffer</h2>

<h3 id="command-pool-组件">Command-Pool 组件</h3>

<p>在创建 Command-Buffer之前，需要创建Command-Pool组件，从Command-Pool中去分配Command-Buffer. 先创建一个VkXXXXCreateInfo的结构体</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Command-Pool 组件
</span><span class="n">VkCommandPool</span> <span class="n">command_pool</span><span class="p">;</span>
<span class="n">VkCommandPoolCreateInfo</span> <span class="n">poolCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span><span class="p">;</span>
<span class="c1">// 可以看到 Command-Pool 还和 Queue 相关联
</span><span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span><span class="p">;</span>
<span class="c1">// 标识命令缓冲区的一些行为
</span><span class="n">poolCreateInfo</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span><span class="p">;</span>
<span class="c1">// 具体创建函数的调用
</span><span class="n">vkCreateCommandPool</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poolCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command_pool</span><span class="p">);</span>
</code></pre>
</div>

<p>有几个参数需要注意：</p>

<ol>
  <li>queueFamilyIndex参数为创建Queue时选择的那个queueFlags为VK_QUEUE_GRAPHICS_BIT 的索引，从Command-Pool中分配的的Command-Buffer必须提交到同一个Queue中。</li>
  <li>flags 有如下的选项，分别指定了 Command-Buffer 的不同特性：</li>
</ol>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandPoolCreateFlagBits</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
    <span class="n">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
    <span class="n">VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandPoolCreateFlagBits</span><span class="p">;</span>
</code></pre>
</div>

<h5 id="vk_command_pool_create_transient_bit">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</h5>

<p>表示该 Command-Buffer 的寿命很短，可能在短时间内被重置或释放</p>

<h5 id="vk_command_pool_create_reset_command_buffer_bit">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</h5>

<p>表示从Command-Pool中分配的Command-Buffer可以通过vkResetCommandBuffer或者vkBeginCommandBuffer方法进行重置，如果没有设置该标识位，就不能调用vkResetCommandBuffer方法进行重置。</p>

<h3 id="command-buffer-组件">Command-Buffer 组件</h3>

<p>接下来就是从Command-Pool中分配Command-Buffer，通过VkCommandBufferAllocateInfo函数。首先需要一个VkCommandBufferAllocateInfo结构体表示分配所需要的信息。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkCommandBufferAllocateInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>         <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>             <span class="n">pNext</span><span class="p">;</span>
    <span class="n">VkCommandPool</span>           <span class="n">commandPool</span><span class="p">;</span>    <span class="c1">// 对应上面创建的 command-pool
</span>    <span class="n">VkCommandBufferLevel</span>    <span class="n">level</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                <span class="n">commandBufferCount</span><span class="p">;</span> <span class="c1">// 创建的个数
</span><span class="p">}</span> <span class="n">VkCommandBufferAllocateInfo</span><span class="p">;</span>
</code></pre>
</div>

<p>其中VkCommandBufferLevel指定Command-Buffer 的级别。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandBufferLevel</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_END_RANGE</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="n">VK_COMMAND_BUFFER_LEVEL_SECONDARY</span> <span class="o">-</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">VK_COMMAND_BUFFER_LEVEL_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandBufferLevel</span><span class="p">;</span>

</code></pre>
</div>
<p>一般来说，使用 VK_COMMAND_BUFFER_LEVEL_PRIMARY 就好了。</p>

<p>具体创建代码如下：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkCommandBuffer</span> <span class="n">commandBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">VkCommandBufferAllocateInfo</span> <span class="n">command_buffer_allocate_info</span><span class="p">{};</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandPool</span> <span class="o">=</span> <span class="n">command_pool</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">commandBufferCount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">command_buffer_allocate_info</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">;</span>
<span class="n">vkAllocateCommandBuffers</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command_buffer_allocate_info</span><span class="p">,</span> <span class="n">commandBuffer</span><span class="p">);</span>
</code></pre>
</div>
<h3 id="command-buffer-的生命周期">Command-Buffer 的生命周期</h3>

<p>创建了 Command-Buffer 之后，它的生命周期，如下图：</p>

<p><img src="/img/post-unity/cmd5.jpeg" alt="" /></p>

<h5 id="initial-状态">Initial 状态</h5>
<p>在 Command-Buffer 刚刚创建时，它就是处于初始化的状态。从此状态，可以达到Recording状态，另外，如果重置之后，也会回到该状态。</p>

<h5 id="recording-状态">Recording 状态</h5>
<p>调用 vkBeginCommandBuffer 方法从Initial状态进入到该状态。一旦进入该状态后，就可以调用vkCmd*等系列方法记录命令。</p>

<h5 id="executable-状态">Executable 状态</h5>
<p>调用vkEndCommandBuffer方法从Recording状态进入到该状态，此状态下，Command-Buffer可以提交或者重置。</p>

<h5 id="pending-状态">Pending 状态</h5>
<p>把Command-Buffer提交到 Queue之后，就会进入到该状态。此状态下，物理设备可能正在处理记录的命令，因此不要在此时更改 Command-Buffer，当处理结束后，Command-Buffer可能会回到Executable状态或者Invalid状态。</p>

<h5 id="invalid-状态">Invalid 状态</h5>
<p>一些操作会使得Command-Buffer进入到此状态，该状态下，Command-Buffer只能重置、或者释放。</p>

<h3 id="command-buffer-的记录与提交">Command-Buffer 的记录与提交</h3>

<p>现在可以尝试着记录一些命令，提交到Queue上了，命令记录的调用过程如下图：</p>

<p><img src="/img/post-unity/cmd6.jpeg" alt="" /></p>

<p>在vkBeginCommandBuffer和vkEndCommandBuffer方法之间可以记录和渲染相关的命令，这里先不考虑中间的过程，直接创建提交。</p>

<h4 id="begin-阶段">begin 阶段</h4>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">VkCommandBufferBeginInfo</span> <span class="n">beginInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">beginInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span><span class="p">;</span>
<span class="n">beginInfo</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="p">;</span>
<span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">beginInfo</span><span class="p">);</span>
</code></pre>
</div>

<p>首先，还是需要创建一个 VkCommandBufferBeginInfo 结构体用来表示 Command-Buffer 开始的信息。<br />
这里要注意的参数是 flags ，表示 Command-Buffer 的用途，</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkCommandBufferUsageFlagBits</span> <span class="p">{</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
    <span class="n">VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkCommandBufferUsageFlagBits</span><span class="p">;</span>
</code></pre>
</div>

<ul>
  <li>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT<br />
表示该Command-Buffer只使用提交一次，用完之后就会被重置，并且每次提交时都需要重新记录</li>
</ul>

<h4 id="end-阶段">end 阶段</h4>

<p>直接调用 vkEndCommandBuffer 方法就可以结束记录，此时就可以提交了。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">vkEndCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre>
</div>

<h3 id="buffer-提交">buffer 提交</h3>

<p>通过vkQueueSubmit方法将Command-Buffer提交到Queue上。同样的还是需要创建一个 VkSubmitInfo 结构体：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkSubmitInfo</span> <span class="p">{</span>
    <span class="n">VkStructureType</span>                <span class="n">sType</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>                    <span class="n">pNext</span><span class="p">;</span>
    <span class="kt">uint32_t</span>                       <span class="n">waitSemaphoreCount</span><span class="p">;</span>  <span class="c1">// 等待的 Semaphore 数量
</span>    <span class="k">const</span> <span class="n">VkSemaphore</span><span class="o">*</span>             <span class="n">pWaitSemaphores</span><span class="p">;</span>     <span class="c1">// 等待的 Semaphore 数组指针
</span>    <span class="k">const</span> <span class="n">VkPipelineStageFlags</span><span class="o">*</span>    <span class="n">pWaitDstStageMask</span><span class="p">;</span>       <span class="c1">// 在哪个阶段进行等待
</span>    <span class="kt">uint32_t</span>                       <span class="n">commandBufferCount</span><span class="p">;</span>  <span class="c1">// 提交的 Command-Buffer 数量
</span>    <span class="k">const</span> <span class="n">VkCommandBuffer</span><span class="o">*</span>         <span class="n">pCommandBuffers</span><span class="p">;</span>      <span class="c1">// 具体的 Command-Buffer 数组指针
</span>    <span class="kt">uint32_t</span>                       <span class="n">signalSemaphoreCount</span><span class="p">;</span>    <span class="c1">//执行结束后通知的 Semaphore 数量
</span>    <span class="k">const</span> <span class="n">VkSemaphore</span><span class="o">*</span>             <span class="n">pSignalSemaphores</span><span class="p">;</span>       <span class="c1">//执行结束后通知的 Semaphore 数组指针
</span><span class="p">}</span> <span class="n">VkSubmitInfo</span><span class="p">;</span>
</code></pre>
</div>
<p>它的参数比较多，并且涉及到Command-Buffer之间的同步关系了，这里简单说一下，后面再细说这一块。如下图，Vulkan中有Semaphore、Fences、Event、Barrier四种机制来保证同步。</p>

<p><img src="/img/post-unity/cmd7.jpeg" alt="" /></p>

<h3 id="semaphore-和-fence">Semaphore 和 Fence</h3>

<h4 id="semaphore">Semaphore</h4>

<p>Semaphore的作用主要是用来向Queue中提交Command-Buffer时实现同步。比如说某个Command-Buffer-B在执行的某个阶段中需要等待另一个Command-Buffer-A执行成功后的结果，同时Command-Buffer-C在某阶段又要要等待Command-Buffer-B的执行结果，那么就应该使用Semaphore机制实现同步；<br />
此时Command-Buffer-B提交到Queue时就需要两个VkSemaphor，一个表示它需要等待的Semaphore，并且指定在哪个阶段等待；一个是它执行结束后发出通知的Semaphore。</p>

<h4 id="fence">Fence</h4>

<p>Fence的作用主要是用来保证物理设备和应用程序之间的同步，比如说向Queue中提交了Command-Buffer后，具体的执行交由物理设备去完成了，这是一个异步的过程，而应用程序如果要等待执行结束，就要使用Fence机制。<br />
Semaphore和Fence有相同之处，但是使用场景却不一样。Semaphore和Fence的创建过程如下，和以往的Vulkan创建对象的调用方式没有太大区别：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 创建 Semaphore
</span><span class="n">VkSemaphore</span> <span class="n">imageAcquiredSemaphore</span><span class="p">;</span>
<span class="n">VkSemaphoreCreateInfo</span> <span class="n">semaphoreCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">semaphoreCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</span><span class="p">;</span>
<span class="n">vkCreateSemaphore</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">semaphoreCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imageAcquiredSemaphore</span><span class="p">);</span>

<span class="c1">// 创建 Fence
</span><span class="n">VkFence</span> <span class="n">drawFence</span><span class="p">;</span>
<span class="n">VkFenceCreateInfo</span> <span class="n">fenceCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">fenceCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_FENCE_CREATE_INFO</span><span class="p">;</span>
<span class="c1">// 该参数表示 Fence 的状态，如果不设置或者为 0 表示 unsignaled state
</span><span class="n">fence_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
<span class="n">vkCreateFence</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenceCreateInfo</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drawFence</span><span class="p">);</span>
</code></pre>
</div>

<p>继续回到VkSubmitInfo结构体中，如果只是简单的提交Command-Buffer，那就不需要考虑Semaphore这些同步机制了，把相应的参数都设置为nullptr，或者直接不设置也行，最后提交就好了，代码如下:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 简单的提交过程
// 开始记录
</span><span class="n">VkCommandBufferBeginInfo</span> <span class="n">beginInfo1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">beginInfo1</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span><span class="p">;</span>
<span class="n">beginInfo1</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</span><span class="p">;</span>
<span class="n">vkBeginCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">beginInfo1</span><span class="p">);</span>

<span class="c1">// 省略中间的 vkCmdXXXX 系列方法
// 结束记录
</span><span class="n">vkEndCommandBuffer</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">VkSubmitInfo</span> <span class="n">submitInfo1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">submitInfo1</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SUBMIT_INFO</span><span class="p">;</span>
<span class="c1">// pWaitSemaphores 和 pSignalSemaphores 都不设置，只是提交
</span><span class="n">submitInfo1</span><span class="p">.</span><span class="n">commandBufferCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">submitInfo1</span><span class="p">.</span><span class="n">pCommandBuffers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">commandBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// 注意最后的参数 临时设置为 VK_NULL_HANDLE，也可以设置为  Fence 来同步
</span><span class="n">vkQueueSubmit</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">submitInfo1</span><span class="p">,</span> <span class="n">VK_NULL_HANDLE</span><span class="p">);</span>
</code></pre>
</div>

<p>以上就完成了Command-Buffer提交到Queue的过程，省略了Semaphores和Fences的同步机制，当然也可以把它们加上。</p>

<p>在vkQueueSubmit的最后一个参数设置为了VK_NULL_HANDLE，这是Vulkan中设置为NULL的一个方法（其实是设置了一个整数0），也可以设置了Fence，表示我们要等待该Command-Buffer在Queue执行结束，虽说Command-Buffer也可以通过Semaphore来表示执行结束，但这两种方式的使用场景不一样。</p>

<p>回到 Fence 的创建过程，其中有一个flags参数表示Fence的状态，有如下两种状态：</p>

<h5 id="signaled-state">signaled state</h5>
<p>如果 flags 参数为 VK_FENCE_CREATE_SIGNALED_BIT 则表示创建后处于该状态。</p>
<h5 id="unsignaled-state">unsignaled state</h5>
<p>默认的状态。</p>

<p>当vkQueueSubmit的最后参数传入Fence后，就可以通过Fence等待该Command-Buffer执行结束。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// wait fence to enter the signaled state on the host
//  错误的 waitForFences 使用，因为它并不是一个阻塞的方法
//  VkResult res = vkWaitForFences(info.device, 1, &amp;fence, VK_TRUE, UINT64_MAX);
</span>    <span class="n">VkResult</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">vkWaitForFences</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fence</span><span class="p">,</span> <span class="n">VK_TRUE</span><span class="p">,</span> <span class="n">UINT64_MAX</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_TIMEOUT</span><span class="p">);</span>
</code></pre>
</div>

<p>vkWaitForFences方法会等待Fence进入signaled state状态，该方法的调用要放在while循环中，因为它并不是一个阻塞的方法，可以理解成一个状态查询，如果结果不对，返回的是VK_TIMEOUT，结果满足要求才返回VK_SUCCESS。当Command-Buffer执行结束后，传入的Fence参数就会从unsignaled state进入到signaled state，从而触发vkWaitForFences调用结束循环，表明执行结束了。</p>

<p><br /><br />
参考链接:<br />
 <a href="https://www.jianshu.com/p/9ee2adb26969">Vulkan 移动开发之 Command Buffer</a><br />
 <a href="https://www.khronos.org/registry/vulkan/specs/1.0/pdf/vkspec.pdf">vkspec.pdf</a></p>


    </div>
  </div>

  <style>
  .post-nav {
    overflow: hidden;
    /* margin-top: 60px; */
    padding: 12px;
    white-space: nowrap;
    /* border-top: 1px solid #eee; */
  }

  .post-nav-item {
    display: inline-block;
    width: 50%;
    white-space: normal;
  }

  .post-nav-item a {
    position: relative;
    display: inline-block;
    line-height: 25px;
    font-size: 14px;
    color: #555;
    border-bottom: none;
  }

  .post-nav-item a:hover {
    color: #222;
    font-weight: bold;
    border-bottom: none;
  }

  .post-nav-item a:active {
    top: 2px;
  }

  .post-nav-item a:before,
  .post-nav-item a:after {
    display: inline-block;
    width: 16px;
    height: 25px;
    vertical-align: top;
    opacity: 0.4;
    background-size: 16px;
  }

  .post-nav-none a:none {
    content: ' ';
    background-size: 8px;
  }

  .post-nav-none a:hover:none {
    opacity: 1;
  }

  .post-nav-prev a:before {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjE4LjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLWxlZnQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxOC41MDAwMDAsIDkwLjAwMDAwMCkiPjxwYXRoIGQ9Ik03LjQsMS40IEw2LDAgTC04Ljg4MTc4NDJlLTE2LDYgTDYsMTIgTDcuNCwxMC42IEwyLjgsNiBMNy40LDEuNCBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=") no-repeat 0 50%;
    background-size: 8px;
  }

  .post-nav-prev a:hover:before {
    opacity: 1;
  }

  .post-nav-next {
    text-align: right;
  }

  .post-nav-next a:after {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYwLjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLXJpZ2h0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNjAuNTAwMDAwLCA5MC4wMDAwMDApIj48cGF0aCBkPSJNMSwwIEwtMC40LDEuNCBMNC4yLDYgTC0wLjQsMTAuNiBMMSwxMiBMNyw2IEwxLDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+") no-repeat 100% 50%;
    background-size: 8px;
  }

  .post-nav-next a:hover:after {
    opacity: 1;
  }
</style>



<div class="post-nav">

  
  <div class="post-nav-none post-nav-item">
    <a href=""> </a>
  </div>
  

  
  <div class="post-nav-next post-nav-item">
    
    <a href="/blog/2019/texturearray/"> TextureArray用法</a>
  </div>
  

</div>

</article>
    </div>

    <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://twitter.com/penghuailiang" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.zhihu.com/people/huailiangpenguin" target="_blank"><i class="icon icon-zhihu"></i></a></li>
  <li><a href="https://www.facebook.com/profile.php?id=100004290725320" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="https://weibo.com/6212299692/profile?topnav=1&wvr=6" target="_blank"><i class="icon icon-sina"></i></a></li>
  <li><a href="https://www.linkedin.com/in/penghuailiang/" target="_blank"><i class="icon icon-linkedin"></i></a></li>
  <li><a href="https://github.com/huailiang" target="_blank"><i class="icon icon-github"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2019 All rights reserved. </small>
    </p>
  </div>
</footer>
    <a href="https://github.com/huailiang" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
    <script>
      $(document).ready(function () {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart', function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
    </script>
  </main>
</body>

</html>