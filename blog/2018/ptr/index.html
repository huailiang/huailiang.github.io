<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>c++ 智能指针</title>
  <meta name="description"
    content="  C++11中有unique_ptr、shared_ptr与weak_ptr等智能指针(smart pointer)，定义在中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。">

  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://huailiang.github.io/blog/2018/ptr/">

</head>

<body>
  <main>
    <header class="site-header">
  <div class="container">
    <h1><a href="/">Hom<span>e</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
        <li><a href="/about" title="About">About</a>
        </li>
        
        <li><a href="/blog" title="Blog">Blog</a>
        </li>
        
       <li><a href="/category/" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>
    <script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });

</script>
    <div class="container">
      <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">c++ 智能指针</h1>
      <p class="post-meta">Jan 23, 2018 •
        Huailiang</p>
    </header>

    <div class="post-content">
      <blockquote>
  <p>C++11中有unique_ptr、shared_ptr与weak_ptr等智能指针(smart pointer)，定义在<memory>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</memory></p>
</blockquote>

<h3 id="1-auto_ptr">1. auto_ptr</h3>

<p>auto_ptr主要是用来解决资源自动释放的问题，比如如下代码：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Function</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Obj</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="n">occor</span><span class="p">)</span>
    <span class="k">throw</span> <span class="p">...</span> <span class="n">or</span> <span class="n">retrun</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>在函数遇到错误之后，一般会抛异常，或者返回，但是这时很可能遗漏之前申请的资源，及时是很有经验的程序员也有可能出现这种错误，而使用auto_ptr会在自己的析够函数中进行资源释放。也就是所说的RAII</p>

<p>使用auto_ptr代码如下</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Function</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Obj</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="n">occur</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">exception</span><span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这样无论函数是否发生异常，在何处返回，资源都会自动释放。需要提一下的是这是一个被c++11标准废弃的一个智能指针，为什么会被废弃，先看一下下面的代码：</p>

<pre><code class="language-C++">auto_ptr&lt;Obj&gt; ptr1( new Obj() );
ptr1-&gt;FuncA();
auto_ptr&lt;Obj&gt; ptr2 = ptr1;
ptr2-&gt;FuncA();
ptr1-&gt;FuncA();  // 这句话会异常
</code></pre>

<p>为什么在把ptr1复制给ptr2之后ptr1再使用就异常了呢？<br />
这也正是他被抛弃的主要原因。因为auto_ptr复制构造函数中把真是引用的内存指针进行的转移，也就是从ptr1转移给了ptr2,此时，ptr2引用了Obj内存地址，而ptr1引用的内存地址为空，此时再使用ptr1就异常了。</p>

<h2 id="2-unique_ptr">2. unique_ptr</h2>

<p>unique_ptr持有对对象的独有权，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p>

<p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">));</span>   <span class="c1">// 无法复制的unique_ptr
//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">up1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>   <span class="c1">// 11
</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">up1</span><span class="p">);</span>    <span class="c1">// 现在p3是数据的唯一的unique_ptr
</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">up3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>   <span class="c1">// 11
//std::cout &lt;&lt; *up1 &lt;&lt; std::endl;   // err, 运行时错误
</span><span class="n">up3</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>            <span class="c1">// 显式释放内存
</span><span class="n">up1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>            <span class="c1">// 不会导致运行时错误
//std::cout &lt;&lt; *up3 &lt;&lt; std::endl;   // err, 运行时错误
</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up4</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">22</span><span class="p">));</span>   <span class="c1">// 无法复制的unique_ptr
</span><span class="n">up4</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">44</span><span class="p">));</span> <span class="c1">//"绑定"动态对象
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">up4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 44
</span>
<span class="n">up4</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span><span class="c1">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价
</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up5</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">55</span><span class="p">));</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">up5</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">//只是释放控制权，不会释放内存
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">//cout &lt;&lt; *up5 &lt;&lt; endl; // err, 运行时错误
</span><span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//释放堆区资源
</span></code></pre>
</div>

<h2 id="3-shared_ptr">3. shared_ptr</h2>

<p>shared_ptr允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">22</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">sp1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cout: "</span> <span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 2
</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span>
<span class="n">sp1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// 显示让引用计数减一
</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count: "</span> <span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// count: 1
</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span></code></pre>
</div>

<h2 id="4-weak_ptr">4. weak_ptr</h2>

<p>weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 * 和 -&gt; 但可以使用lock获得一个可用的shared_ptr对象</p>

<p>weak_ptr的使用更为复杂一点，它可以指向shared_ptr指针指向的对象内存，却并不拥有该内存，而使用weak_ptr成员lock，则可返回其指向内存的一个share_ptr对象，且在所指对象内存已经无效时，返回指针空值nullptr。</p>

<p>注意：weak_ptr并不拥有资源的所有权，所以不能直接使用资源。可以从一个weak_ptr构造一个shared_ptr以取得共享资源的所有权。</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#define _CRT_SECURE_NO_WARNINGS
</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
</span>
<span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">wp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// 转换为shared_ptr&lt;int&gt;
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"still: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"still: "</span> <span class="o">&lt;&lt;</span> <span class="s">"pointer is invalid"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">mytest</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">22</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">sp1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">sp1</span><span class="p">;</span> <span class="c1">// 指向shared_ptr&lt;int&gt;所指对象
</span>    <span class="c1">// std::cout &lt;&lt; *wp &lt;&lt; std::endl; 编译不过
</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count: "</span> <span class="o">&lt;&lt;</span> <span class="n">wp</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// count: 2
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span>    <span class="n">check</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span> <span class="c1">// still: 22
</span>    
    <span class="n">sp1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count: "</span> <span class="o">&lt;&lt;</span> <span class="n">wp</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// count: 1
</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">sp2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 22
</span>    <span class="n">check</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span> <span class="c1">// still: 22
</span>
    <span class="n">sp2</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count: "</span> <span class="o">&lt;&lt;</span> <span class="n">wp</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// count: 0
</span>    <span class="n">check</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span> <span class="c1">// still: pointer is invalid
</span><span class="p">}</span>
</code></pre>
</div>

<h2 id="5-comptr">5. ComPtr</h2>

<h4 id="iunknown接口类">IUnknown接口类</h4>

<p>DirectX11的API是由一系列的COM组件来管理的，这些前缀带I的接口类最终都继承自IUnknown接口类。IUnknown的三个方法如下：</p>

<table>
<thead>
<tr>
  <th width="30%">方法</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>IUnknown::AddRef</td>
  <td>内部引用计数加1。在每次复制了一个这样的指针后，应当调用该方法以保证计数准确性</td>
</tr>
<tr>
  <td>IUnknown::QueryInterface</td>
  <td>查询该实例是否实现了另一个接口，如果存在则返回该接口的指针，并且对该接口的引用计数加1</td>
</tr>
<tr>
  <td>IUnknown::Release</td>
  <td>内部引用数减1。只有当内部引用数到达0时才会真正释放</td>
</tr>
</tbody>
</table>

<p>在实际的使用情况来看，通常我们几乎不会使用第一个方法。而用的最多的就是第三个方法了，每次用完该实例后，我们必须要使用类似下面的宏来释放：</p>

<pre><code class="language-C++">#define ReleaseCOM(x) { if(x){ x-&gt;Release(); x = nullptr; } }
</code></pre>

<p>而且如果出现了忘记释放某个接口指针的情况话，内存泄漏的提醒就有可能够你去调试一整天了。</p>

<h4 id="comptr智能指针">ComPtr智能指针</h4>

<p>为了解决上述问题，从繁杂的人工释放中解脱，在本教程中大量使用了ComPtr智能指针。而且在龙书12的教程源码中也用到了该智能指针。该智能指针可以帮助我们来管理这些COM组件实现的接口实例，而无需过多担心内存的泄漏。该智能指针的大小和一般的指针大小是一致的，没有额外的内存空间占用。所以本教程可以不需要用到接口类ID3D11Debug来协助检查内存泄漏。</p>

<p>使用该智能指针需要包含头文件wrl/client.h，并且智能指针类模板ComPtr位于名称空间Microsoft::WRL内。</p>

<p>首先有五个比较常用的方法需要了解一下：</p>

<table>
<thead>
<tr>
  <th width="30%">方法 </th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="center">Get</td>
  <td>该方法返回T*，并且不会触发引用计数加1，常用在COM组件接口的函数输入</td>
</tr>
<tr>
  <td align="center">GetAddressOf</td>
  <td>该方法返回T**，常用在COM组件接口的函数输出</td>
</tr>
<tr>
  <td align="center">Reset</td>
  <td>相当于先调用Reset方法，再调用GetAddressOf方法获取T**，常用在COM组件接口的函数输出，适用于实例可能会被反复构造</td>
</tr>
<tr>
  <td align="center">ReleaseAndGetAddressOf</td>
  <td>可以和nullptr，或者另一个ComPtr实例进行比较</td>
</tr>
<tr>
  <td align="center">As</td>
  <td>一个模板函数，可以替代IUnknown::QueryInterface的调用，需要传递一个ComPtr实例的地址</td>
</tr>
</tbody>
</table>

<p>然后是一些运算符重载的方法：</p>

<table>
<thead>
<tr>
  <th width="15%">运算符</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="center">&amp;</td>
  <td>相当于调用了ReleaseAndGetAddressOf方法，不推荐使用</td>
</tr>
<tr>
  <td align="center">-&gt;</td>
  <td>和裸指针的行为一致</td>
</tr>
<tr>
  <td align="center">=</td>
  <td>不要将裸指针指向的实例赋给它，若传递的是ComPtr的不同实例则发生交换</td>
</tr>
<tr>
  <td align="center">==和!=</td>
  <td>可以和nullptr，或者另一个ComPtr实例进行比较</td>
</tr>
</tbody>
</table>

<p>注意：大致在比10.0.16299.0更早的Windows SDK版本中，ComPtr使用了一个RemoveIUnknownBase类模板将IUnknown的三个接口都设为了private，以防止用户直接操作这些方法，这也就使得ComPtr无法直接使用COM组件的QueryInterface方法。因此，使用ComPtr<T>::As是一种合适的选择。</T></p>

<p>个人建议，在使用该智能指针后就应该要避免使用IUnknown提供的三个接口方法来进行操作。虽然替换成ComPtr后代码量变长了，但是带来的收益肯定比你自己花费大量时间在检查释放内存上强的多。下面的D3DApp将所有COM组件指针都换成了ComPtr：</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">D3DApp</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">D3DApp</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hInstance</span><span class="p">);</span>        <span class="c1">// 在构造函数的初始化列表应当设置好初始参数
</span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">D3DApp</span><span class="p">();</span>

    <span class="n">HINSTANCE</span> <span class="n">AppInst</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>           <span class="c1">// 获取应用实例的句柄
</span>    <span class="n">HWND</span>      <span class="n">MainWnd</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>           <span class="c1">// 获取主窗口句柄
</span>    <span class="kt">float</span>     <span class="n">AspectRatio</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>       <span class="c1">// 获取屏幕宽高比
</span>    <span class="kt">int</span> <span class="n">Run</span><span class="p">();</span>                          <span class="c1">// 运行程序，进行游戏主循环
</span>
    <span class="c1">// 框架方法。客户派生类需要重载这些方法以实现特定的应用需求                                     
</span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Init</span><span class="p">();</span>                      <span class="c1">// 该父类方法需要初始化窗口和Direct3D部分
</span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnResize</span><span class="p">();</span>                  <span class="c1">// 该父类方法需要在窗口大小变动的时候调用
</span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">UpdateScene</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 子类需要实现该方法，完成每一帧的更新
</span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">DrawScene</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>             <span class="c1">// 子类需要实现该方法，完成每一帧的绘制
</span>    <span class="k">virtual</span> <span class="n">LRESULT</span> <span class="n">MsgProc</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">lParam</span><span class="p">);</span>
    <span class="c1">// 窗口的消息回调函数
</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">InitMainWindow</span><span class="p">();</span>      <span class="c1">// 窗口初始化
</span>    <span class="kt">bool</span> <span class="n">InitDirect3D</span><span class="p">();</span>        <span class="c1">// Direct3D初始化
</span>    <span class="kt">void</span> <span class="n">CalculateFrameStats</span><span class="p">();</span> <span class="c1">// 计算每秒帧数并在窗口显示
</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">HINSTANCE</span> <span class="n">m_hAppInst</span><span class="p">;</span>        <span class="c1">// 应用实例句柄
</span>    <span class="n">HWND</span>      <span class="n">m_hMainWnd</span><span class="p">;</span>        <span class="c1">// 主窗口句柄
</span>    <span class="kt">bool</span>      <span class="n">m_AppPaused</span><span class="p">;</span>       <span class="c1">// 应用是否暂停
</span>    <span class="kt">bool</span>      <span class="n">m_Minimized</span><span class="p">;</span>       <span class="c1">// 应用是否最小化
</span>    <span class="kt">bool</span>      <span class="n">m_Maximized</span><span class="p">;</span>       <span class="c1">// 应用是否最大化
</span>    <span class="kt">bool</span>      <span class="n">m_Resizing</span><span class="p">;</span>        <span class="c1">// 窗口大小是否变化
</span>    <span class="kt">bool</span>      <span class="n">m_Enable4xMsaa</span><span class="p">;</span>    <span class="c1">// 是否开启4倍多重采样
</span>    <span class="n">UINT</span>      <span class="n">m_4xMsaaQuality</span><span class="p">;</span>   <span class="c1">// MSAA支持的质量等级
</span>    <span class="n">GameTimer</span> <span class="n">m_Timer</span><span class="p">;</span>           <span class="c1">// 计时器
</span>
    <span class="c1">// 使用模板别名(C++11)简化类型名
</span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">ComPtr</span> <span class="o">=</span> <span class="n">Microsoft</span><span class="o">::</span><span class="n">WRL</span><span class="o">::</span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="c1">// Direct3D 11
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11Device</span><span class="o">&gt;</span> <span class="n">m_pd3dDevice</span><span class="p">;</span>                    <span class="c1">// D3D11设备
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11DeviceContext</span><span class="o">&gt;</span> <span class="n">m_pd3dImmediateContext</span><span class="p">;</span>   <span class="c1">// D3D11设备上下文
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDXGISwapChain</span><span class="o">&gt;</span> <span class="n">m_pSwapChain</span><span class="p">;</span>                  <span class="c1">// D3D11交换链
</span>    <span class="c1">// Direct3D 11.1
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11Device1</span><span class="o">&gt;</span> <span class="n">m_pd3dDevice1</span><span class="p">;</span>                  <span class="c1">// D3D11.1设备
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11DeviceContext1</span><span class="o">&gt;</span> <span class="n">m_pd3dImmediateContext1</span><span class="p">;</span> <span class="c1">// D3D11.1设备上下文
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDXGISwapChain1</span><span class="o">&gt;</span> <span class="n">m_pSwapChain1</span><span class="p">;</span>                <span class="c1">// D3D11.1交换链
</span>    <span class="c1">// 常用资源
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11Texture2D</span><span class="o">&gt;</span> <span class="n">m_pDepthStencilBuffer</span><span class="p">;</span>        <span class="c1">// 深度模板缓冲区
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11RenderTargetView</span><span class="o">&gt;</span> <span class="n">m_pRenderTargetView</span><span class="p">;</span>   <span class="c1">// 渲染目标视图
</span>    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D11DepthStencilView</span><span class="o">&gt;</span> <span class="n">m_pDepthStencilView</span><span class="p">;</span>   <span class="c1">// 深度模板视图
</span>    <span class="n">D3D11_VIEWPORT</span> <span class="n">m_ScreenViewport</span><span class="p">;</span>                      <span class="c1">// 视口
</span>
    <span class="c1">// 派生类应该在构造函数设置好这些自定义的初始参数
</span>    <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">m_MainWndCaption</span><span class="p">;</span>                       <span class="c1">// 主窗口标题
</span>    <span class="kt">int</span> <span class="n">m_ClientWidth</span><span class="p">;</span>                                   <span class="c1">// 视口宽度
</span>    <span class="kt">int</span> <span class="n">m_ClientHeight</span><span class="p">;</span>                                  <span class="c1">// 视口高度
</span><span class="p">};</span>
</code></pre>
</div>


    </div>
  </div>

  <style>
  .post-nav {
    overflow: hidden;
    /* margin-top: 60px; */
    padding: 12px;
    white-space: nowrap;
    /* border-top: 1px solid #eee; */
  }

  .post-nav-item {
    display: inline-block;
    width: 50%;
    white-space: normal;
  }

  .post-nav-item a {
    position: relative;
    display: inline-block;
    line-height: 25px;
    font-size: 14px;
    color: #555;
    border-bottom: none;
  }

  .post-nav-item a:hover {
    color: #222;
    font-weight: bold;
    border-bottom: none;
  }

  .post-nav-item a:active {
    top: 2px;
  }

  .post-nav-item a:before,
  .post-nav-item a:after {
    display: inline-block;
    width: 16px;
    height: 25px;
    vertical-align: top;
    opacity: 0.4;
    background-size: 16px;
  }

  .post-nav-none a:none {
    content: ' ';
    background-size: 8px;
  }

  .post-nav-none a:hover:none {
    opacity: 1;
  }

  .post-nav-prev a:before {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjE4LjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLWxlZnQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxOC41MDAwMDAsIDkwLjAwMDAwMCkiPjxwYXRoIGQ9Ik03LjQsMS40IEw2LDAgTC04Ljg4MTc4NDJlLTE2LDYgTDYsMTIgTDcuNCwxMC42IEwyLjgsNiBMNy40LDEuNCBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=") no-repeat 0 50%;
    background-size: 8px;
  }

  .post-nav-prev a:hover:before {
    opacity: 1;
  }

  .post-nav-next {
    text-align: right;
  }

  .post-nav-next a:after {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYwLjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLXJpZ2h0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNjAuNTAwMDAwLCA5MC4wMDAwMDApIj48cGF0aCBkPSJNMSwwIEwtMC40LDEuNCBMNC4yLDYgTC0wLjQsMTAuNiBMMSwxMiBMNyw2IEwxLDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+") no-repeat 100% 50%;
    background-size: 8px;
  }

  .post-nav-next a:hover:after {
    opacity: 1;
  }
</style>



<div class="post-nav">

  
  <div class="post-nav-prev post-nav-item">
    
    <a href="/blog/2018/luafix/"> 如何使用lua做热更新的</a>
  </div>
  

  

</div>

</article>
    </div>

    <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://twitter.com/penghuailiang" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.zhihu.com/people/huailiangpenguin" target="_blank"><i class="icon icon-zhihu"></i></a></li>
  <li><a href="https://www.facebook.com/profile.php?id=100004290725320" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="https://weibo.com/6212299692/profile?topnav=1&wvr=6" target="_blank"><i class="icon icon-sina"></i></a></li>
  <li><a href="https://www.linkedin.com/in/penghuailiang/" target="_blank"><i class="icon icon-linkedin"></i></a></li>
  <li><a href="https://github.com/huailiang" target="_blank"><i class="icon icon-github"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2020 All rights reserved. </small>
    </p>
  </div>
</footer>
    <a href="https://github.com/huailiang" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
    <script>
      $(document).ready(function () {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart', function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
    </script>
  </main>
</body>

</html>