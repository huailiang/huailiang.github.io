<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>图形噪声</title>
  <meta name="description"
    content="  大自然蕴含着各式各样的纹理，小到细胞菌落分布，大到宇宙星球表面。运用图形噪声，我们可以在3d场景中模拟它们，本文就带大家一起走进万能的图形噪声。 图形噪声，是计算机图形学中一类随机算法，经常用来模拟自然界中的各种纹理材质，如下图的云、山脉等，都是通过噪声算法模拟出来的​。">

  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://huailiang.github.io/blog/2021/noise/">

</head>

<body>
  <main>
    <header class="site-header">
  <div class="container">
    <h1><a href="/">Hom<span>e</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
        <li><a href="/about" title="About">About</a>
        </li>
        
        <li><a href="/blog" title="Blog">Blog</a>
        </li>
        
       <li><a href="/category/" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>
    <script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });

</script>
    <div class="container">
      <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">图形噪声</h1>
      <p class="post-meta">Apr 9, 2021 •
        huailiang</p>
    </header>

    <div class="post-content">
      <blockquote>
  <p>大自然蕴含着各式各样的纹理，小到细胞菌落分布，大到宇宙星球表面。运用图形噪声，我们可以在3d场景中模拟它们，本文就带大家一起走进万能的图形噪声。 图形噪声，是计算机图形学中一类随机算法，经常用来模拟自然界中的各种纹理材质，如下图的云、山脉等，都是通过噪声算法模拟出来的​。</p>
</blockquote>

<p><img src="/img/post-engine/noise1.jpg" alt="" /></p>

<p>通过不同的噪声算法，作用在物体纹理和材质细节，我们可以模拟不同类型的材质。</p>

<p><img src="/img/post-engine/noise2.jpg" alt="" /></p>

<h3 id="基础噪声算法">基础噪声算法</h3>

<p>一个基础的噪声函数的入参通常是一个点坐标（这个点坐标可以是二维的、三维的，甚至N维），返回值是一个浮点数值：noise(vec2(x,y))。<br />
我们将这个浮点值转成灰度颜色，形成噪声图，具体可以通过编写片元着色器程序来绘制。</p>

<p><img src="/img/post-engine/noise3.jpg" alt="" /></p>

<p>上图是各类噪声函数在片元着色器中的运行效果，代码如下：</p>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// noise fragment shader
</span><span class="k">varying</span> <span class="kt">vec2</span> <span class="n">uv</span><span class="p">;</span>
<span class="kt">float</span> <span class="nf">noise</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO
</span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">n</span> <span class="o">=</span> <span class="n">noise</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>  <span class="c1">// 通过噪声函数计算片元坐标对应噪声值
</span>    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>其中noise(uv)的入参uv是片元坐标，返回的噪声值映射在片元的颜色上。<br />
目前基础噪声算法比较主流的有两类：1. 梯度噪声；2. 细胞噪声；</p>

<h3 id="梯度噪声-gradient-noise">梯度噪声 (Gradient Noise)</h3>

<p>梯度噪声产生的纹理具有连续性，所以经常用来模拟山脉、云朵等具有连续性的物质，该类噪声的典型代表是Perlin Noise。</p>

<p><img src="/img/post-engine/noise4.jpg" alt="" /></p>

<p>其它梯度噪声还有Simplex Noise和Wavelet Noise，它们也是由Perlin Noise演变而来。</p>

<h4 id="算法步骤">算法步骤</h4>

<p>梯度噪声是通过多个随机梯度相互影响计算得到，通过梯度向量的方向与片元的位置计算噪声值。这里以2d举例，主要分为四步：1. 网格生成；2. 网格随机梯度生成；3. 梯度贡献值计算；4. 平滑插值</p>

<p><img src="/img/post-engine/noise5.jpg" alt="" /></p>

<p>第一步，我们将2d平面分成m×n个大小相同的网格，具体数值取决于我们需要生成的纹理密度（下面以4×4作为例子）；</p>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="cp">#define SCALE 4. // 将平面分为 4 × 4 个正方形网格
</span><span class="kt">float</span> <span class="nf">noise</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">p</span> <span class="o">*=</span> <span class="n">SCALE</span><span class="p">;</span>
  <span class="c1">// TODO
</span><span class="p">}</span>
</code></pre>
</div>
<p>第二步，梯度向量生成，这一步是根据第一步生成的网格的顶点来产生随机向量，四个顶点就有四个梯度向量；</p>

<p><img src="/img/post-engine/noise6.jpg" alt="" /></p>

<p>我们需要将每个网格对应的随机向量记录下来，确保不同片元在相同网格中获取的随机向量是一致的。</p>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// 输入网格顶点位置，输出随机向量
</span><span class="kt">vec2</span> <span class="n">random</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">){</span>
    <span class="k">return</span>  <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">fract</span><span class="p">(</span>
        <span class="n">sin</span><span class="p">(</span>
            <span class="kt">vec2</span><span class="p">(</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">127</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="mi">311</span><span class="p">.</span><span class="mi">7</span><span class="p">)),</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">269</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">183</span><span class="p">.</span><span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="mi">43758</span><span class="p">.</span><span class="mi">5453</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>如上，借用三角函数sin(θ)的来生成随机值，入参是网格顶点的坐标，返回值是随机向量。</p>

<p>第三步，梯度贡献计算，这一步是通过计算四个梯度向量对当前片元点P的影响，主要先求出点P到四个顶点的距离向量，然后和对应的梯度向量进行点积。</p>

<p><img src="/img/post-engine/noise7.jpg" alt="" /></p>

<p>如图，网格内的片元点P的四个顶点距离向量为a1, a2, a3, a4，此时将距离向量与梯度向量g1, g2, g3, g4进行点积运算：c[i] = a[i] · g[i]；</p>

<p>第四步，平滑插值，这一步我们对四个贡献值进行线性叠加，使用smoothstep()方法，平滑网格边界，最终得到当前片元的噪声值。具体代码如下：</p>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">noise_perlin</span> <span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">i</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 获取当前网格索引i
</span>    <span class="kt">vec2</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fract</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 获取当前片元在网格内的相对位置
</span>    <span class="c1">// 计算梯度贡献值
</span>    <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">random</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 梯度向量与距离向量点积运算
</span>    <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">random</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">.,</span> <span class="mi">0</span><span class="p">.)),</span><span class="n">f</span> <span class="o">-</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">.,</span> <span class="mi">0</span><span class="p">.));</span>
    <span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">random</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">.,</span> <span class="mi">1</span><span class="p">.)),</span><span class="n">f</span> <span class="o">-</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">.,</span> <span class="mi">1</span><span class="p">.));</span>
    <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">random</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">.,</span> <span class="mi">1</span><span class="p">.)),</span><span class="n">f</span> <span class="o">-</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">.,</span> <span class="mi">1</span><span class="p">.));</span>
    <span class="c1">// 平滑插值
</span>    <span class="kt">vec2</span> <span class="n">u</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="mi">0</span><span class="p">.,</span><span class="mi">1</span><span class="p">.,</span><span class="n">f</span><span class="p">);</span>
    <span class="c1">// 叠加四个梯度贡献值
</span>    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">mix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">),</span><span class="n">mix</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">),</span><span class="n">u</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p><a href="https://www.shadertoy.com/view/sdjGWc">Perlin-Noise-Texture的生成代码</a>我已上传ShaderToy， 预览如下（国内加载有点儿慢）。</p>

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/sdjGWc?gui=true&amp;t=10&amp;paused=false&amp;muted=true" allowfullscreen=""></iframe>

<h3 id="细胞噪声-celluar-noise">细胞噪声 (Celluar Noise)</h3>

<p><img src="/img/post-engine/noise8.jpg" alt="" /></p>

<p>Celluar Noise生成的噪声图由很多个“晶胞”组成，每个晶胞向外扩张，晶胞之间相互抑制。这类噪声可以模拟细胞形态、皮革纹理等。</p>

<p><img src="/img/post-engine/noise9.jpg" alt="" /></p>

<h4 id="算法步骤-1">算法步骤</h4>

<p>细胞噪声算法主要通过距离场的形式实现的，以单个特征点为中心的径向渐变，多个特征点共同作用而成。主要分为三步：1. 网格生成；2. 特征点生成；3. 最近特征点计算</p>

<p><img src="/img/post-engine/noise10.jpg" alt="" /></p>

<p>第一步，网格生成：将平面划分为m×n个网格，这一步和梯度噪声的第一步一样；<br />
第二步，特征点生成：为每个网格分配一个特征点v[i,j]，这个特征点的位置在网格内随机。</p>
<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// 输入网格索引，输出网格特征点坐标
</span><span class="kt">vec2</span> <span class="n">random</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">st</span><span class="p">){</span>
    <span class="k">return</span>  <span class="n">fract</span><span class="p">(</span>
        <span class="n">sin</span><span class="p">(</span>
            <span class="kt">vec2</span><span class="p">(</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">127</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="mi">311</span><span class="p">.</span><span class="mi">7</span><span class="p">)),</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">269</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">183</span><span class="p">.</span><span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="o">*</span> <span class="mi">43758</span><span class="p">.</span><span class="mi">5453</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>第三步，针对当前像素点p，计算出距离点p最近的特征点v，将点p到点v的距离记为F1；</p>
<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">noise</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">i</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 获取当前网格索引i
</span>    <span class="kt">vec2</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fract</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 获取当前片元在网格内的相对位置
</span>    <span class="kt">float</span> <span class="n">F1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.;</span>
    <span class="c1">// 遍历当前像素点相邻的9个网格特征点
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">vec2</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="kt">vec2</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="kt">float</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
            <span class="kt">vec2</span> <span class="n">point</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">point</span> <span class="o">+</span> <span class="n">neighbor</span> <span class="o">-</span> <span class="n">f</span><span class="p">);</span>
            <span class="n">F1</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">F1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>求解F1，我们可以遍历所有特征点v，计算每个特征点v到点p的距离，再取出最小的距离F1；但实际上，我们只需遍历离点p最近的网格特征点即可。在2d中，则最多遍历包括自身相连的9个网格，如图：</p>

<p><img src="/img/post-engine/noise11.jpg" alt="" /></p>

<p>最后一步，将F1映射为当前像素点的颜色值，可以是gl_FragColor = vec4(vec3(pow(noise(uv), 2.)), 1.0);。<br />
不仅如此，我们还可以取特征点v到点p第二近的距离F2，通过F2 - F1，得到类似泰森多变形的纹理，如上图最右侧。</p>

<p><a href="https://www.shadertoy.com/view/ss2GWc">Celluar Noise Texture 生成算法</a>我已经上传ShaderToy， 预览如下 (国内加载有点慢)：</p>

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ss2GWc?gui=true&amp;t=10&amp;paused=false&amp;muted=true" allowfullscreen=""></iframe>

<h3 id="噪声算法组合">噪声算法组合</h3>

<p>前面介绍了两种主流的基础噪声算法，我们可以通过对多个不同频率的同类噪声进行运算，产生更为自然的效果，下图是经过分形操作后的噪声纹理。</p>

<p><img src="/img/post-engine/noise12.jpg" alt="" /></p>

<h5 id="分形布朗运动fractal-brownian-motion">分形布朗运动（Fractal Brownian Motion）</h5>

<p>分形布朗运动，简称fbm，是通过将不同频率和振幅的噪声函数进行操作，最常用的方法是：将频率乘2的倍数，振幅除2的倍数，线性相加。</p>

<p><img src="/img/post-engine/noise13.jpg" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>公式：fbm = noise(st) + 0.5 * noise(2*st) + 0.25 * noise(4*st)
</code></pre>
</div>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// fragment shader片元着色器
</span><span class="cp">#define OCTAVE_NUM 5
</span><span class="c1">// 叠加5次的分形噪声
</span><span class="kt">float</span> <span class="nf">fbm_noise</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OCTAVE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">noise</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">.;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>基于 PerlinNoise 的<a href="https://www.shadertoy.com/view/ssj3Wc">fbm算法</a>在 ShaderToy 中预览如下 (国内加载有点慢)：</p>

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ssfSWn?gui=true&amp;t=10&amp;paused=false&amp;muted=true" allowfullscreen=""></iframe>

<h5 id="湍流turbulence">湍流（Turbulence）</h5>

<p>另外一种变种是在fbm中对噪声函数取绝对值，使噪声值等于0处发生突变，产生湍流纹理：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>公式：fbm = |noise(st)| + 0.5 * |noise(2*st)| + 0.25 * |noise(4*st)|
</code></pre>
</div>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// 湍流分形噪声
</span><span class="kt">float</span> <span class="nf">fbm_abs_noise</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OCTAVE_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f</span> <span class="o">+=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">(</span><span class="n">p</span><span class="p">));</span> <span class="c1">// 对噪声函数取绝对值
</span>        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>基于 PerlinNoise 的<a href="https://www.shadertoy.com/view/ssj3Wc">Turbulence算法</a>在 ShaderToy 中预览如下 (国内加载有点慢)：</p>

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ssj3Wc?gui=true&amp;t=10&amp;paused=false&amp;muted=true" allowfullscreen=""></iframe>

<h5 id="翘曲域domain-wrapping">翘曲域（Domain Wrapping）</h5>

<p><img src="/img/post-engine/noise15.jpg" alt="" /></p>

<p>翘曲域噪声用来模拟卷曲、螺旋状的纹理，比如烟雾、大理石等，实现公式如下：</p>

<p>对于图像定义为函数f(x,y), 更紧凑地写为f(p)，其中p是空间中的位置，我们可以据此评估定义（等）表面或图像颜色的体积密度。弯曲只是意味着我们在评估f之前用另一个函数g(p)扭曲域。基本上，我们将f(p)替换为f(g(p))。g可以是任何东西，有意义的是让g(p)就是恒等式加上一个小的任意失真h(p), 即：</p>

<script type="math/tex; mode=display">g(p)= p + h(p)</script>

<p>这种技术非常强大，可让您塑造苹果，建筑物，动物或您可能想象的其他任何东西。 我们针对f和h使用基于fBM, 产生一些抽象但美丽的图像，并具有相当的品相。</p>

<p><img src="/img/post-engine/noise14.jpg" alt="" /></p>

<script type="math/tex; mode=display">f(p) = fBM(p)</script>

<p>我们对初始的fBM公式进行变换：</p>

<script type="math/tex; mode=display">f(p) =  fBM(p + fBM(p) )</script>

<p>代码如下：</p>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">pattern</span><span class="p">(</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">q</span> <span class="o">=</span> <span class="kt">vec2</span><span class="p">(</span> <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">),</span>
                   <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>进行更复杂的变换：</p>

<script type="math/tex; mode=display">f(p) = fBM(p + fBM(p + fBM(p)))</script>

<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">pattern</span><span class="p">(</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">q</span> <span class="o">=</span> <span class="kt">vec2</span><span class="p">(</span> <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">),</span>
                   <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">5</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

    <span class="kt">vec2</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">vec2</span><span class="p">(</span> <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">.</span><span class="mi">2</span><span class="p">)</span> <span class="p">),</span>
                   <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span> <span class="o">+</span> <span class="kt">vec2</span><span class="p">(</span><span class="mi">8</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">.</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">fbm</span><span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="o">*</span><span class="n">r</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>实现效果参考shadertoy的预览（国内加载可能有点儿慢）：</p>

<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/4s23zz?gui=true&amp;t=10&amp;paused=false&amp;muted=true" allowfullscreen=""></iframe>

<h4 id="动态纹理">动态纹理</h4>

<p>前面讲的都是基于2d平面的静态噪声，我们还可以在2d基础上加上时间t维度，形成动态的噪声。</p>

<p><img src="/img/post-engine/noise16.gif" alt="" /></p>

<p>如下为实现3d noise的代码结构：</p>
<div class="language-glsl highlighter-rouge"><pre class="highlight"><code><span class="c1">// noise fragment shader
</span><span class="cp">#define SPEED 20.
</span><span class="k">varying</span> <span class="kt">vec2</span> <span class="n">uv</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">u_time</span><span class="p">;</span>
<span class="kt">float</span> <span class="nf">noise</span><span class="p">(</span><span class="kt">vec3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO
</span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">n</span> <span class="o">=</span> <span class="n">noise</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">u_time</span> <span class="o">*</span>  <span class="n">SPEED</span><span class="p">);</span>  <span class="c1">// 传入片元坐标与时间
</span>    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>利用时间，我们可以生成实现动态纹理，模拟如火焰、云朵的变换。</p>

<p><img src="/img/post-engine/noise17.gif" alt="" /></p>

<h3 id="噪声贴图应用">噪声贴图应用</h3>

<p>利用噪声算法，我们可以构造物体表面的纹理颜色和材质细节，在3d开发中，一般采用贴图方式应用在3D Object上的Material材质上。</p>

<h5 id="color-mapping">Color Mapping</h5>

<p>彩色贴图是最常用的是方式，即直接将噪声值映射为片元颜色值，作为材质的Texture图案。</p>

<p><img src="/img/post-engine/noise18.jpg" alt="" /></p>

<h5 id="height-mapping">Height Mapping</h5>

<p>另一种是作为Height Mapping高度贴图，生成地形高度。高度贴图的每个像素映射到平面点的高度值，通过图形噪声生成的Height Map可模拟连绵起伏的山脉。</p>

<p><img src="/img/post-engine/noise19.jpg" alt="" /></p>

<h5 id="normal-mapping">Normal Mapping</h5>

<p>除了通过heightMap生成地形，还可以通过法线贴图改变光照效果，实现材质表面的凹凸细节。<br />
<img src="/img/post-engine/noise20.jpg" alt="" /></p>

<p>这里的噪声值被映射为法线贴图的color值。</p>

<p>参考文献： <br />
1、<a href="https://max.book118.com/html/2019/0301/6135100204002012.shtm">《大自然的分形几何学》[波] 伯努瓦·B. 曼德布罗特（Mandelbrot）</a><br />
2、<a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">Perlin Noise</a><br />
3、<a href="http://www.gamersky.com/handbook/201601/708963_2.shtml?tag=wap">关于噪声的一些基本定义</a><br />
4、<a href="hhttps://thebookofshaders.com/13/">Fractal Brownian Motion</a><br />
5、<a href="https://flafla2.github.io/2014/08/09/perlinnoise.html">Understanding Perlin Noise</a><br />
6、<a href="http://blog.csdn.net/candycat1992/article/details/50346469">谈谈噪声</a> <br />
7、<a href="https://zhuanlan.zhihu.com/p/88518193">基于ComputeShader生成Perlin Noise噪声图</a><br />
8、<a href="http://adrianb.io/2014/08/09/perlinnoise.html">Understanding Perlin Noise</a></p>


    </div>
  </div>

  <style>
  .post-nav {
    overflow: hidden;
    /* margin-top: 60px; */
    padding: 12px;
    white-space: nowrap;
    /* border-top: 1px solid #eee; */
  }

  .post-nav-item {
    display: inline-block;
    width: 50%;
    white-space: normal;
  }

  .post-nav-item a {
    position: relative;
    display: inline-block;
    line-height: 25px;
    font-size: 14px;
    color: #555;
    border-bottom: none;
  }

  .post-nav-item a:hover {
    color: #222;
    font-weight: bold;
    border-bottom: none;
  }

  .post-nav-item a:active {
    top: 2px;
  }

  .post-nav-item a:before,
  .post-nav-item a:after {
    display: inline-block;
    width: 16px;
    height: 25px;
    vertical-align: top;
    opacity: 0.4;
    background-size: 16px;
  }

  .post-nav-none a:none {
    content: ' ';
    background-size: 8px;
  }

  .post-nav-none a:hover:none {
    opacity: 1;
  }

  .post-nav-prev a:before {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjE4LjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLWxlZnQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxOC41MDAwMDAsIDkwLjAwMDAwMCkiPjxwYXRoIGQ9Ik03LjQsMS40IEw2LDAgTC04Ljg4MTc4NDJlLTE2LDYgTDYsMTIgTDcuNCwxMC42IEwyLjgsNiBMNy40LDEuNCBaIiBpZD0iU2hhcGUiLz48L2c+PC9nPjwvZz48L3N2Zz4=") no-repeat 0 50%;
    background-size: 8px;
  }

  .post-nav-prev a:hover:before {
    opacity: 1;
  }

  .post-nav-next {
    text-align: right;
  }

  .post-nav-next a:after {
    content: ' ';
    background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA5IDEyIiB3aWR0aD0iOXB4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlLz48ZGVzYy8+PGRlZnMvPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGZpbGw9IiMwMDAwMDAiIGlkPSJDb3JlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjYwLjAwMDAwMCwgLTkwLjAwMDAwMCkiPjxnIGlkPSJjaGV2cm9uLXJpZ2h0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNjAuNTAwMDAwLCA5MC4wMDAwMDApIj48cGF0aCBkPSJNMSwwIEwtMC40LDEuNCBMNC4yLDYgTC0wLjQsMTAuNiBMMSwxMiBMNyw2IEwxLDAgWiIgaWQ9IlNoYXBlIi8+PC9nPjwvZz48L2c+PC9zdmc+") no-repeat 100% 50%;
    background-size: 8px;
  }

  .post-nav-next a:hover:after {
    opacity: 1;
  }
</style>



<div class="post-nav">

  
  <div class="post-nav-none post-nav-item">
    <a href=""> </a>
  </div>
  

  
  <div class="post-nav-next post-nav-item">
    
    <a href="/blog/2021/shadertoy/"> ShaderToy</a>
  </div>
  

</div>

</article>
    </div>

    <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://twitter.com/penghuailiang" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.zhihu.com/people/huailiangpenguin" target="_blank"><i class="icon icon-zhihu"></i></a></li>
  <li><a href="https://www.facebook.com/profile.php?id=100004290725320" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="https://weibo.com/6212299692/profile?topnav=1&wvr=6" target="_blank"><i class="icon icon-sina"></i></a></li>
  <li><a href="https://www.linkedin.com/in/penghuailiang/" target="_blank"><i class="icon icon-linkedin"></i></a></li>
  <li><a href="https://github.com/huailiang" target="_blank"><i class="icon icon-github"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2021 All rights reserved. </small>
    </p>
  </div>
</footer>
    <a href="https://github.com/huailiang" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
    <script>
      $(document).ready(function () {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart', function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
    </script>
  </main>
</body>

</html>