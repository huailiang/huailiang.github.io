---
layout:     post
title:      "云渲染"
date:       2023-04-19 02:00:00
author:     "huailiang"
tags:
    - 人工智能
---



考虑将高负载的“渲染”放置到能力强大的后端，解放前端， 为此一些游戏引擎厂商提出了一种新的三维“云渲染”方案-基于WebRTC的视频流推送技术：
* UE称之为 [PixelStreaming][i4]；
* Unity称之为 [RenderStreaming][i5]；

由于基本原理一致，就是将场景通过后端渲染，然后采用实时视频流推送到网页端，并且能够实现前端到后端的交互同步。通过 WebRTC 协 议将其发送给位于接收端的浏览器和设备。事实上，通过在高性能主机系统上运行渲染引擎，用户能在所有终 端设备上享受到与主机相同的画质，并且能体验到所有的渲染引擎功能。


WebRTC(网页实时通信)是一种通过网页浏览器和移动应用程序进行实时通信的协议。该协议允许以直接链接 的方式传输音频和视频，用户无需下载任何插件或应用程序。通信命令通过 API 接口提交，前端只要声明一个 video 标签就可以实现视频流的加载和交互。

## Unreal

UE5云渲染方案概述
UE5云渲染方案叫[PixelStreaming](https://docs.unrealengine.com/5.1/en-US/pixel-streaming-in-unreal-engine/)



## 启动
- UE启用Pixel Streaming插件

- 下载PixelStreamingInfrastucture源码，执行setup.bat下载依赖，本地会自动生成 nexe 和 coturn 文件夹。  node是nodejs本地执行环境， 如果不想在脚本下载， 可以直接copy过来， 注意版本号对齐， 默认是：v16.4.2

![](/img/post-render/ue1.PNG)

- 执行`Start_SignallingServer`启动服务器

![](image/ue2.PNG)

- 启动UE打包的客户端，启动参数传` -AudioMixer -PixelStreamingURL=ws://localhost:8888 -RenderOffScreen`

- 连接服务器，网页输入127.0.0.1:8080测试, 


当有客户端连接时， 会有如下提示：

![](/img/post-render/ue3.PNG)


配置文件位于**SignallingWebServer**的Config.json下，配置内容如下， 这里可以修改启动的服务器的端口：

```json
{
	"UseFrontend": false,
	"UseMatchmaker": false,
	"UseHTTPS": false,
	"UseAuthentication": false,
	"LogToFile": true,
	"LogVerbose": true,
	"HomepageFile": "player.html",
	"AdditionalRoutes": {},
	"EnableWebserver": true,
	"MatchmakerAddress": "",
	"MatchmakerPort": "9999",
	"PublicIp": "localhost",
	"HttpPort": 8080,
	"HttpsPort": 443,
	"StreamerPort": 8888,
	"SFUPort": 8889,
	"MaxPlayerCount": -1
}
```

浏览器启来之后效果如下：

![](/img/post-render/ue4.PNG)


## Unity


![](/img/post-render/unity1.png)



![](/img/post-render/unity2.png)

其中offer的调用过程可以参考：

![](/img/post-render/offer.PNG)


发起方的信令变化：

```
have-local-offer -> stable
```

被叫方的信令变化

```
have-remote-offer -> stable
```


### singaling 状态：

当我们一开始创建这个RTCPeerConnection的时候，它处于stable状态，就是处于一个稳定状态，

这个时候实际connection就可以用了，但用的时候它是不能进行这个编解码的，为什么呢？

因为他没有进行数据协商对吧，虽然我这个connection类是可以用，但是并没有进行数据协商，所以他没法儿进行数据的传输与编解码，怎么才能进行数据传输编解码呢?

那就发生了一个状态的改变，就是比如对于调用者来说，首先创建了connection之后他要创建这个offer，创建offer之后,

通过调用那个setLocalDescription将这个offer设进去之后; 他就状态变化了，变成什么呢，变成have-local-offer,

但是我设完这个之后, 如果对方没有给我回他的answer的时候, 那实际我的状态就一直处于have-local-offer,

无论我在接受多少次这个setLocalDescription方法仍在处理这个状态，所以他自己对自己的一个循环对我仍然处于这个状态，

那这个状态是不会变的，那什么时候才会变呢?

只有在你远端的answer回来的时候，像我刚才讲的远端的answer创建好，然后通过消息传给这个调用者的时候，那它才会调用这个setRemoteDescription，

那么将answer设进去之后，他又回到了stable状态，这个时候RTCpeerConnection又可以用了，而且是已经协商过的了。

__这时候他可以进行编解码和传输了，这是对于调用者来说。__

那么对于这个被调用者来说呢，同样道理，那当他收到这个offer之后呢，它要调用setRemote offer，这个时候，他从那个stable状态就变成了have-remote-offer，那同样的，当他自己创建了一个answer之后，并且调用了setLocalDescription这个方法将answer设置进去之后，他又从这个remote-offer变成了stable状态，那这个时候他又可以工作了。


![](/img/post-render/state.png)


如上图所示，媒体协商状态变化除了stable状态外，还有have-local-offer以及have-remote-offer：

首先在创建offer之后呢，会调用setLocalDescription将这个offer设置进去，那他的状态呢，就变成了have-local-offer，

那当他收到对端的这个answer之后呢，它会调用setRemoteDescription将这个offer设置进去，这样就完成了一个协商，所以他就从这个have-local-offer变为了stable状态，那他就可以继续下面的工作了，

而对于被调用者，他首先呢是从信令服务器收到一个offer，那他首先调用setRemoteDescription这个offer，那它就变成了have-remote-offer状态，

这个时候,他在调用自己的这个create answer, 创建完自己的这个answer之后,
它调用setLocalDescription answer就从这个have-remote-offer变为了stable状态，这样的被调用者他也就完成了自己的协商工作，可以继续下面的这个操作了，

但是还是两种情况,会有一种中间的这个状态叫做PRanswer,就是提前应答,这个状态是什么时候会产生呢?

就是在双方通讯的时候其中被调用者还没有准备好数据的时候，那可以先创建一个临时的这个answer，这个临时的answer有一个特点就是: 它没有媒体数据也就是说没有音频流和视频流，并且将这个发送的方向设置成send only

对于B来说，他回的这个answer是一个什么样的answer呢 ?

就是说，我的媒体流还没有准备好，所以就没有媒体流，但是我呢，只能发送，不能接受，当他发给对方A的时候，A收到这样一个send only，他就知道，对方还不能进入数据，

所以这时候他们的通讯虽然是做了的协商，但是他们之间还不能进行通讯。

因为第一个是对方没有媒体流，第二个是对方不接受我的数据。处于这样一个状态有什么好处呢？

那就是可以提前建立这个链路的连接，也就是说包括ICE，包括这个DLS这些跟链路相关的这个协商其实都已经创建好了，对刚才我们已经介绍了，就是对于B来说，他已经提前准备好了一个answer，但这个answer里有没有媒体数据，但是实际是有网络数据的，我收集的各种各种候选者实际都已经有了。

那么就可以提前交给这个A，那A与B之间，实际就是链路层已经协商好了，包括这个DLS还要进行这个握手，它因为是安全加密，加密所以要进行握手，握手的时间其实还是蛮长的，那在B准备好这个自己的流之前，将所有的链路都准备好，那一旦这个B向那个用户申请：说想开启音频和视频，当用户授权说可以，这个时候呢，他们拿到数据之后，只要将数据传进去，就可以进行这个通讯了。

所以在B没有准备好之前，他可以使用一个PRanswer，就是提前预定好的一个answer给这个A发过去，发过去之后呢，它就变成了这个have-remote-offer这个状态，这是一个中间状态，

在这个状态下，双方的这个链路是可以协商好的，只是没有这个媒体数据，当那个B设置好他自己的媒体流之后，就是一切都准备好之后，然后再给他回一个最终的answer，当调用者收到它这个最终的answer之后，他又变成了stable状态，那双方就可以就真正协商好了。

这时候，实际是减少了底层的这个网络流的这个握手，以及一些其他的逻辑处理工作，这样就节省了时间。

但对于被调用者也是类似的，所以在他回这个真正的answer之前，它是处于这have-local-PRanswer的，当真正的这个最终的Answer，准备好之后呢，再重新设一下setLocalAnswer，他又变成了stable状态，这就是一个整个协商完整的一个状态变化。

只有在整个协商完成之后，才能进行我们后边儿的真正的音视频数据的传输以及编解码。
这就是协商状态的变化。



如果双方同时在本地生成了offer， 然后同时发给了对方， 肯定会协商失败


A polite peer, 如果将要设置的信令与本身的信令状态有冲突， 就会使用回滚， 使用自身的信令状态变为stable后继续设置对方发来的信令

A impolite peer, 如果将设置的信令与本身信令状态有冲突， 就会放弃设置对方的信令（以我为准）

双方谁是polite peer 和 impolite peer 没有限制， 是可以随机的。




编译webapp 执行如下：

```sh
cd WebApp
npm install
npm run build
npm run start
```

使用 ts-node 运行server:

```sh
npm run dev
```

打包发布：

```sh
npm run pack
```

npm run之类的命令， 实际执行的 package.json里的配置， 比如 build 执行的是：

```
tsc -p tsconfig.build.json
```

start执行的是：

```
node ./build/index.js
```


## Typescript 环境


Typescript 在webstorm 中调试环境配置


大体上来看3大步：

* 安装ts-node
* 为ts-node创建一个自定义Node.js运行/调试配置



安装 ts_node, 直接在终端上执行下面的命名

```ts
npm install ts-node
```

创建 运行调试配置：



![](/img/post-render/ts1.PNG)


[i1]: https://blog.csdn.net/qq_43303950/article/details/128878032
[i2]: https://docs.unity3d.com/Packages/com.unity.renderstreaming@3.1/manual/customize-webapp.html
[i3]: https://docs.unity3d.com/Packages/com.unity.renderstreaming@3.1/manual/customize-webapp.html
[i4]: https://docs.unrealengine.com/5.1/en-US/pixel-streaming-sample-project-for-unreal-engine/
[i5]: https://docs.unity3d.com/Packages/com.unity.renderstreaming@3.1/manual/overview.html